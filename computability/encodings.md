---
layout: math
title: Encodings
nav_order: 6
mathjax: true
parent: Computability
---

# Encoding pairs

A __pairing function__ is a bijection $\mathbb{N} \times \mathbb{N}
\xrightarrow{\cong} \mathbb{N}$.

It is not immediately evident that a pairing function might exist: why should
it be possible to put $\mathbb{N}$ and $\mathbb{N} \times \mathbb{N}$ in
*exact* correspondence with each other? Does not the product set $\mathbb{N}
\times \mathbb{N}$ have somehow 'infinitely more' elements than $\mathbb{N}$?

Nevertheless, [a variety of pairing
functions](https://en.wikipedia.org/wiki/Pairing_function) exists.

* The [Cantor pairing
  function](https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function)
  scans the 'plane'
  [diagonally](https://en.wikipedia.org/wiki/Pairing_function#/media/File:Cantor's_Pairing_Function.svg).

* [Other pairing functions](https://en.wikipedia.org/wiki/Pairing_function#/media/File:Diagonal_argument.svg) cover the plane in a [boustrophedon](https://en.wikipedia.org/wiki/Boustrophedon) pattern (that of an ox plowing a field)

* ... and there are [many other variants](https://mathworld.wolfram.com/PairingFunction.html).

# Encoding lists

Once we have a pairing function $\phi : \mathbb{N} \times \mathbb{N}
\xrightarrow{\cong} \mathbb{N}$ and its inverse $\phi^{-1} : \mathbb{N}
\xrightarrow{\cong} \mathbb{N} \times \mathbb{N}$ then we can use them to
encode all sorts of other data.

For example, we may encode lists of natural numbers, i.e. elements of the set

$$
  \mathbb{N}^\ast = \{ [n_1, \dots, n_k] \mid k \geq 0, \forall i. n_i \in \mathbb{N} \}
$$

as natural numbers. To encode we define a function $\phi_\ast :
\mathbb{N}^\ast \to \mathbb{N}$ by induction:

$$
  \begin{aligned}
    \phi_\ast([])   &= 0 \\
    \phi_\ast(n:ns) &= 1 + \phi(n, \phi_\ast(ns))
  \end{aligned}
$$

This function is a bijection. They key to writing down the inverse is to
notice that all operations used in its definition ($\phi$, $+1$) are
invertible. We define $\phi_\ast^{-1} : \mathbb{N} \to \mathbb{N}^\ast$ by

$$
  \begin{aligned}
    \phi_\ast^{-1}(n) = \begin{cases}
      []                     & \text{ if $n = 0$} \\
      x : \phi_\ast^{-1}(m) & \text{ if $n > 0$ and $(x, m) = \phi^{-1}(n - 1)$}
    \end{cases}
  \end{aligned}
$$

# Encoding binary trees

The bijection $\phi : \mathbb{N} \times \mathbb{N} \xrightarrow{\cong}
\mathbb{N}$ is unbelievably convenient. For example, using it twice allows us to package three natural numbers together. That is, we can construct a bijection

$$
  \begin{aligned}
  & \phi_3 : \mathbb{N} \times \mathbb{N} \times \mathbb{N} \to \mathbb{N} \\
  & \phi_3(n_1, n_2, n_3) = \phi(n_1, \phi(n_2, n_3))
  \end{aligned}
$$

by applying $\phi$ twice. Naturally, the inverse consists of applying
$\phi^{-1}$ twice:

$$
  \begin{aligned}
  & \phi_3^{-1} : \mathbb{N} \to \mathbb{N} \times \mathbb{N} \times \mathbb{N} \\
  & \phi_3(n) = (n_1, n_2, n_3) \\
  & \quad\quad\quad \text{ where $(n_1, x) = \phi^{-1}(n)$ and $(n_2, n_3) = \phi^{-1}(x)$}
  \end{aligned}
$$

This can then be used to encode binary trees.
[Recall](https://uob-coms20007.github.io/reference/while/abstract-syntax.html#denoting-abstract-syntax-linearly-backus-naur-form)
that the set $T$ of __binary trees (decorated with natural numbers)__ is
generated by the Backus-Naur form

$$
t_1, t_2, \dots :≔\ \text{•}\ \mid \ \textsf{fork}(n, t_1, t_2)
$$

where we write $\text{•}$ to denote the empty tree, and $\textsf{fork}(n,
t_1, t_2)$ to denote the tree decorated with a natural number $n \in
\mathbb{N}$, and with left subtree $t_1 \in T$, and right subtree $t_2 \in
T$.

This set $T$ can then be put in bijection with the natural numbers as
follows. We define a function $\phi_T : T \to \mathbb{N}$ by induction on
trees:

$$
  \begin{aligned}
    \phi_T(\text{•})                   &= 0 \\
    \phi_T(\textsf{fork}(n, t_1, t_2)) &= 1 + \phi(n, \phi(\phi_T(t_1), \phi_T(t_2)))
  \end{aligned}
$$

This encoding combines the ideas used to encode
[lists](https://uob-coms20007.github.io/reference/computability/encodings.html#encoding-lists)
with the ideas used to encode triples of natural numbers.

It is not difficult to write down the inverse; we recommend it as a
proverbial exercise for the reader.