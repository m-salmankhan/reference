---
layout: math
title: Encodings
nav_order: 6
mathjax: true
parent: Computability
---

# Encoding pairs

A __pairing function__ is a bijection $\mathbb{N} \times \mathbb{N}
\xrightarrow{\cong} \mathbb{N}$.

It is not immediately evident that a pairing function might exist: why should
it be possible to put $\mathbb{N}$ and $\mathbb{N} \times \mathbb{N}$ in
*exact* correspondence with each other? Does not the product set $\mathbb{N}
\times \mathbb{N}$ have somehow 'infinitely more' elements than $\mathbb{N}$?

Nevertheless, [a variety of pairing
functions](https://en.wikipedia.org/wiki/Pairing_function) exists.

* The [Cantor pairing
  function](https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function)
  scans the 'plane'
  [diagonally](https://en.wikipedia.org/wiki/Pairing_function#/media/File:Cantor's_Pairing_Function.svg).

* [Other pairing functions](https://en.wikipedia.org/wiki/Pairing_function#/media/File:Diagonal_argument.svg) cover the plane in a [boustrophedon](https://en.wikipedia.org/wiki/Boustrophedon) pattern (that of an ox plowing a field)

* ... and there are [many other variants](https://mathworld.wolfram.com/PairingFunction.html).

# Encoding lists

Once we have a pairing function $\phi : \mathbb{N} \xrightarrow{\cong}
\mathbb{N} \to \mathbb{N}$ and its inverse $\phi^{-1} : \mathbb{N}
\xrightarrow{\cong} \mathbb{N} \times \mathbb{N}$ then we can use them to
encode all sorts of other data.

For example, we may encode lists of natural numbers, i.e. elements of the set

$$
  \mathbb{N}^\ast = \{ [n_1, \dots, n_k] \mid k \geq 0, \forall i. n_i \in \mathbb{N} \}
$$

as natural numbers. To encode we define a function $\phi_\ast :
\mathbb{N}^\ast \to \mathbb{N}$ by induction:

$$
  \begin{aligned}
    \phi_\ast([])   &= 0 \\
    \phi_\ast(n:ns) &= 1 + \phi(n, \phi_\ast(ns))
  \end{aligned}
$$

This function is a bijection. They key to writing down the inverse is to
notice that all operations are reversible. We define $\phi_\ast^{-1} :
\mathbb{N} \to \mathbb{N}^\ast$ by

$$
  \begin{aligned}
    \phi_\ast^{-1}(n) = \begin{cases}
      []                     & \text{ if $n = 0$} \\
      x : \phi_\ast^{-1}(m) & \text{ if $n > 0$ and $(x, m) = \phi^{-1}(n)$}
    \end{cases}
  \end{aligned}
$$

# Encoding binary trees

The bijection $\phi : \mathbb{N} \times \mathbb{N} \xrightarrow{\cong}
\mathbb{N}$ is unbelievably convenient. For example, using it twice allows us to package three natural numbers together. That is, we can construct a bijection

$$
  \begin{aligned}
  & \phi_3 : \mathbb{N} \times \mathbb{N} \times \mathbb{N} \to \mathbb{N} \\
  & \phi_3(n_1, n_2, n_3) = \phi(n_1, \phi(n_2, n_3))
  \end{aligned}
$$

by applying $\phi$ twice. Naturally, the inverse consists of applying
$\phi^{-1}$ twice:

$$
  \begin{aligned}
  & \phi_3^{-1} : \mathbb{N} \to \mathbb{N} \times \mathbb{N} \times \mathbb{N} \\
  & \phi_3(n) = (n_1, n_2, n_3) \\
  & \quad\quad\quad \text{ where $(n_1, x) = \phi^{-1}(n)$ and $(n_2, n_3) = \phi^{-1}(x)$}
  \end{aligned}
$$

This can then be used to encode binary trees.
[Recall](https://uob-coms20007.github.io/reference/while/abstract-syntax.html#denoting-abstract-syntax-linearly-backus-naur-form)
that the set $T$ of binary trees (decorated with natural numbers) is
generated by the Backus-Naur form
$$
t_1, t_2, \dots :≔\ \text{•}\ \mid \ \textsf{fork}(n, t_1, t_2)
$$
where we write $\text{•}$ to denote the empty tree, and $\textsf{fork}(n,
t_1, t_2)$ to denote the tree decorated with a natural number $n \in
\mathbb{N}$, and with left subtree $t_1 \in T$, and right subtree $t_2 \in
T$.

This set $T$ can then be put in bijection with the natural numbers as
follows. We define a function $\phi_T : T \to \mathbb{N}$ by induction on
trees:

$$
  \begin{aligned}
    \phi_T(\text{•})                   &= 0 \\
    \phi_T(\textsf{fork}(n, t_1, t_2)) &= 1 + \phi(n, \phi(\phi_T(t_1), \phi_T(t_2)))
  \end{aligned}
$$

This encoding combines the ideas used to encode
[lists](https://uob-coms20007.github.io/reference/computability/encodings.html#encoding-lists)
with the ideas used to encode triples of natural numbers.

It is not difficult to write down the inverse; we recommend it as a
proverbial exercise for the reader.

# Gödel numbering

We have now shown how to put the following things in bijection with the
natural numbers:
[integers](https://uob-coms20007.github.io/reference/computability/bijections.html#bijection-between-naturals-and-integers),
[pairs of
naturals](https://uob-coms20007.github.io/reference/computability/encodings.html#pairing-function),
[lists of
naturals](https://uob-coms20007.github.io/reference/computability/encodings.html#encoding-lists),
and [binary trees of
naturals](https://uob-coms20007.github.io/reference/computability/encodings.html#encoding-binary-trees).

But in the previous part of the course we saw that While programs themselves
may be represented as an [Abstract Syntax Tree
(AST)](https://uob-coms20007.github.io/reference/while/abstract-syntax.html).
So it is not a stretch of the imagination to imagine that we may encode While
ASTs as natural numbers.

As While's chief data type is that of integers, an encoding of this sort
means that _we will be able to compute functions that modify or act on While
programs within While itself_. This sounds somewhat paradoxical, but it
isn't. You will explore the way this is done in next week's Haskell-based
problem sheet.

Encodings of "systems" (logical systems, programming languages, etc.) in
themselves are often called __Gödel numberings__. They were first proposed by
the great logician [Kurt
Gödel](https://en.wikipedia.org/wiki/Kurt_G%C3%B6del) in the proof of his celebrated
[incompleteness
theorems](https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems).

Gödel numberings allow us to prove various __impossibility results__ about
logical systems and/or programming languages. All these proofs proceed
through constructions that seem quasi-paradoxical (but, again, are not). The
apparent paradox often implies that the programming language has some
limitation, i.e. is unable to achieve some task (compute a function, decide a
predicate, etc.). We will see such a result next week.

There is a [significant amount of
lore](https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach) surrounding
Gödel numberings. However, this lore somewhat overstates their importance.
When decoded intuitively, most impossibility results amount to statements  "a
Parliament cannot grant itself amnesty by its own vote: it must recruit some
external authority larger than itself."


